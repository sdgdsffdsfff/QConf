#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include "gtest/gtest.h"
#include "qconf_map.h"
#include "format_util.h"
#include "const_def.h"
#include "qlibc.h"


#define MAX_SLOT_COUNT (800000)

//unit test case for qconf_map.c

//Related test environment set up and tear down
static qhasharr_t* tbl = NULL;

class qconf_mapTestF : public ::testing::Test
{
protected:
    static void SetUpTestCase()
    {
        init_qhasharr_lock();
        init_hash_tbl(&tbl, shmkey, 0666);
    }
    virtual void SetUp()
    {
    }

    virtual void TearDown()
    {
        qhasharr_clear(tbl);
    }

    static void TearDownTestCase()
    {
        destroy_qhasharr_lock();
        tbl = NULL;
    }

    static const key_t shmkey = 0x1010ac02;
};

/**
  *Begin_Test_for function: int hash_tbl_set_with_md5(qhasharr_t* tbl, const char* key, char* val)
  *================================================================================================
  */

//Test for hash_tbl_set_with_md5: tbl->maxslots=0
TEST(qconf_mapTest, hash_tbl_set_with_md5_zero_maxslots)
{
    int retCode = 0;
    const char* key = "hello";
    const char* val = "12345";
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;

    memsize = qhasharr_calculate_memsize(0);
    memory = (char*)malloc(sizeof(char) * memsize);
    memset(memory, 0, memsize);
    tbl = (qhasharr_t*)memory;
    tbl->maxslots = 0;

    retCode = hash_tbl_set_with_md5(tbl, key, val);

    EXPECT_EQ(QCONF_FAILED, retCode);
    free(tbl);
    tbl = NULL;
}

//Test for hash_tbl_set_with_md5: key not exists in tbl
TEST_F(qconf_mapTestF, hash_tbl_set_with_md5_key_not_exists_in_tbl)
{
    int retCode = 0;
    const char* key = "hello";
    const char* val = "12345";
    size_t len = 0;
    char* tmp = NULL;

    retCode = hash_tbl_set_with_md5(tbl, key, val);
    tmp = hash_tbl_get_with_checking_md5(tbl, key, &len);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(5ul, len);
    EXPECT_EQ(0, strcmp(val, tmp));
    free(tmp);
    tmp = NULL;
}

//Test for hash_tbl_set_with_md5: new value equals with old value
TEST_F(qconf_mapTestF, hash_tbl_set_with_md5_new_value_equals_with_old_value)
{
    int retCode = 0;
    const char* key = "hello";
    const char* val = "12345";
    char *value_tmp = NULL;
    int value_tmp_len = 0;
    char value_md5_int[QCONF_MD5_INT_LEN] = {0};
    char value_md5_str[QCONF_MD5_STR_LEN + 1] = {0};

    qhashmd5(val, strlen(val), value_md5_int);
    md5_int_to_str(value_md5_str, QCONF_MD5_STR_LEN + 1, value_md5_int, QCONF_MD5_INT_LEN);
    value_tmp_len = strlen(val) + QCONF_MD5_STR_HEAD_LEN + 1;
    value_tmp = (char*) malloc(sizeof(char) * value_tmp_len);
    snprintf(value_tmp, value_tmp_len, "%d:%s%s", QCONF_MD5_STR_LEN, value_md5_str, val);
    qhasharr_put(tbl, key, value_tmp, value_tmp_len);

    retCode = hash_tbl_set_with_md5(tbl, key, val);

    EXPECT_EQ(QCONF_ERR_SAME_VALUE, retCode);
    free(value_tmp);
    value_tmp = NULL;
}

//Test for hash_tbl_set_with_md5: new value not equals with old value
TEST_F(qconf_mapTestF, hash_tbl_set_with_md5_new_value_not_equals_with_old_value)
{
    int retCode = 0;
    const char* key = "hello";
    const char* val = "12345";
    char *value_tmp = NULL;
    int value_tmp_len = 0;
    char value_md5_int[QCONF_MD5_INT_LEN] = {0};
    char value_md5_str[QCONF_MD5_STR_LEN + 1] = {0};

    qhashmd5(val, strlen(val), value_md5_int);
    md5_int_to_str(value_md5_str, QCONF_MD5_STR_LEN + 1, value_md5_int, QCONF_MD5_INT_LEN);
    value_tmp_len = strlen(val) + QCONF_MD5_STR_HEAD_LEN + 1;
    value_tmp = (char*) malloc(sizeof(char) * value_tmp_len);
    snprintf(value_tmp, value_tmp_len, "%d:%s%s", QCONF_MD5_STR_LEN, value_md5_str, val);
    qhasharr_put(tbl, key, value_tmp, value_tmp_len);

    retCode = hash_tbl_set_with_md5(tbl, key, "12345 ");
    size_t len = 0;
    char * tmp = hash_tbl_get_with_checking_md5(tbl, key, &len);
    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(0, strcmp("12345 ", tmp));
    EXPECT_EQ(6ul, len);
    free(value_tmp);
    free(tmp);
    value_tmp = NULL;
    tmp = NULL;
}

//Test for hash_tbl_set_with_md5: old value needs 2 slots but new value need 1 slot
TEST_F(qconf_mapTestF, hash_tbl_set_with_md5_size_of_new_value_less_than_old_value)
{
    int retCode = 0;
    const char* key = "hello";
    const char* val = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";
    const char* newval = "111111";
    char *value_tmp = NULL;
    int value_tmp_len = 0;
    char value_md5_int[QCONF_MD5_INT_LEN] = {0};
    char value_md5_str[QCONF_MD5_STR_LEN + 1] = {0};

    qhashmd5(val, strlen(val), value_md5_int);
    md5_int_to_str(value_md5_str, QCONF_MD5_STR_LEN + 1, value_md5_int, QCONF_MD5_INT_LEN);
    value_tmp_len = strlen(val) + QCONF_MD5_STR_HEAD_LEN + 1;
    value_tmp = (char*) malloc(sizeof(char) * value_tmp_len);
    snprintf(value_tmp, value_tmp_len, "%d:%s%s", QCONF_MD5_STR_LEN, value_md5_str, val);
    qhasharr_put(tbl, key, value_tmp, value_tmp_len);

    retCode = hash_tbl_set_with_md5(tbl, key, newval);
    size_t len = 0;
    char * tmp = hash_tbl_get_with_checking_md5(tbl, key, &len);
    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(0, strcmp(newval, tmp));
    EXPECT_EQ(6ul, len);
    EXPECT_EQ(1, tbl->usedslots);
    free(value_tmp);
    free(tmp);
    value_tmp = NULL;
    tmp = NULL;
}

////Test for hash_tbl_set_with_md5: old value needs 1 slots but new value need 2 slot
TEST_F(qconf_mapTestF, hash_tbl_set_with_md5_size_of_new_value_more_than_old_value)
{
    int retCode = 0;
    const char* key = "hello";
    const char* val = "111111";
    const char* newval = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";
    char *value_tmp = NULL;
    int value_tmp_len = 0;
    char value_md5_int[QCONF_MD5_INT_LEN] = {0};
    char value_md5_str[QCONF_MD5_STR_LEN + 1] = {0};

    qhashmd5(val, strlen(val), value_md5_int);
    md5_int_to_str(value_md5_str, QCONF_MD5_STR_LEN + 1, value_md5_int, QCONF_MD5_INT_LEN);
    value_tmp_len = strlen(val) + QCONF_MD5_STR_HEAD_LEN + 1;
    value_tmp = (char*) malloc(sizeof(char) * value_tmp_len);
    snprintf(value_tmp, value_tmp_len, "%d:%s%s", QCONF_MD5_STR_LEN, value_md5_str, val);
    qhasharr_put(tbl, key, value_tmp, value_tmp_len);

    retCode = hash_tbl_set_with_md5(tbl, key, newval);
    size_t len = 0;
    char * tmp = hash_tbl_get_with_checking_md5(tbl, key, &len);
    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(0, strcmp(newval, tmp));
    EXPECT_EQ(78ul, len);
    EXPECT_EQ(2, tbl->usedslots);
    free(value_tmp);
    free(tmp);
    value_tmp = NULL;
    tmp = NULL;
}

//Test for hash_tbl_set_with_md5: key not exists and usedslots = maxslots
TEST(qconf_mapTest, hash_tbl_set_with_md5_usedslots_equals_with_maxslots)
{
    int retCode = 0;
    const char* keys[] = {"abc", "def", "hijk", "lmn", "opq"};;
    const char* vals[] = {"123", "111", "1234", "555", "hihihi"};
    const char* key = "hello";
    const char* val = "111";
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;
    char value_md5_int[QCONF_MD5_INT_LEN] = {0};
    char value_md5_str[QCONF_MD5_STR_LEN + 1] = {0};
    char *value_tmp = NULL;
    int value_tmp_len = 0;

    memsize = qhasharr_calculate_memsize(5);
    memory = (char*)malloc(sizeof(char) * memsize);
    tbl = qhasharr(memory, memsize);

    for(int i = 0; i < 5; i++)
    {
        qhashmd5(vals[i], strlen(vals[i]), value_md5_int);
        md5_int_to_str(value_md5_str, QCONF_MD5_STR_LEN + 1, value_md5_int, QCONF_MD5_INT_LEN);
        value_tmp_len = strlen(vals[i]) + QCONF_MD5_STR_HEAD_LEN + 1;
        value_tmp = (char*) malloc(sizeof(char) * value_tmp_len);
        snprintf(value_tmp, value_tmp_len, "%d:%s%s", QCONF_MD5_STR_LEN, value_md5_str, vals[i]);
        qhasharr_put(tbl, keys[i], value_tmp, value_tmp_len);
        free(value_tmp);
        value_tmp = NULL;
    }

    retCode = hash_tbl_set_with_md5(tbl, key, val);

    EXPECT_EQ(QCONF_FAILED, retCode);
    EXPECT_EQ(5, tbl->usedslots);
    free(tbl);
    tbl = NULL;
}

//Test for hash_tbl_set_with_md5: key not exists and num of slots can be used is 1,but value needs 2 slots
TEST(qconf_mapTest, hash_tbl_set_with_md5_sum_of_usedslots_and_needsslots_more_than_maxslots)
{
    int retCode = 0;
    const char* keys[] = {"abc", "def", "hijk", "lmn"};;
    const char* vals[] = {"123", "111", "1234", "555",};
    const char* key = "abcd";
    const char* val = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz012345678901234567890";
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;
    char value_md5_int[QCONF_MD5_INT_LEN] = {0};
    char value_md5_str[QCONF_MD5_STR_LEN + 1] = {0};
    char *value_tmp = NULL;
    int value_tmp_len = 0;

    memsize = qhasharr_calculate_memsize(5);
    memory = (char*)malloc(sizeof(char) * memsize);
    tbl = qhasharr(memory, memsize);

    for(int i = 0; i < 4; i++)
    {
        qhashmd5(vals[i], strlen(vals[i]), value_md5_int);
        md5_int_to_str(value_md5_str, QCONF_MD5_STR_LEN + 1, value_md5_int, QCONF_MD5_INT_LEN);
        value_tmp_len = strlen(vals[i]) + QCONF_MD5_STR_HEAD_LEN + 1;
        value_tmp = (char*) malloc(sizeof(char) * value_tmp_len);
        snprintf(value_tmp, value_tmp_len, "%d:%s%s", QCONF_MD5_STR_LEN, value_md5_str, vals[i]);
        qhasharr_put(tbl, keys[i], value_tmp, value_tmp_len);
        free(value_tmp);
        value_tmp = NULL;
    }

    retCode = hash_tbl_set_with_md5(tbl, key, val);
    //size_t len = 0;
//    char* tmp = hash_tbl_get_with_checking_md5(tbl, key, &len);

    EXPECT_EQ(QCONF_FAILED, retCode);

    free(tbl);
    tbl = NULL;
}

//Test for hash_tbl_set_with_md5: key exists and new value needs 3 slots and old value needs 1 slot
TEST(qconf_mapTest, hash_tbl_set_with_md5_sum_of_usedslots_and_needsslots_more_than_maxslots2)
{
    int retCode = 0;
    const char* keys[] = {"abc", "def", "hijk", "lmn"};;
    const char* vals[] = {"123", "111", "1234", "555",};
    const char* key = "abc";
    char val[244] = {0};
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;
    char value_md5_int[QCONF_MD5_INT_LEN] = {0};
    char value_md5_str[QCONF_MD5_STR_LEN + 1] = {0};
    char *value_tmp = NULL;
    int value_tmp_len = 0;
    int i;

    for(i = 0; i < 243; i++)
    {
        val[i] = 'a';
    }

    val[i] = '\0';
    memsize = qhasharr_calculate_memsize(5);
    memory = (char*)malloc(sizeof(char) * memsize);
    tbl = qhasharr(memory, memsize);

    for(int i = 0; i < 4; i++)
    {
        qhashmd5(vals[i], strlen(vals[i]), value_md5_int);
        md5_int_to_str(value_md5_str, QCONF_MD5_STR_LEN + 1, value_md5_int, QCONF_MD5_INT_LEN);
        value_tmp_len = strlen(vals[i]) + QCONF_MD5_STR_HEAD_LEN + 1;
        value_tmp = (char*) malloc(sizeof(char) * value_tmp_len);
        snprintf(value_tmp, value_tmp_len, "%d:%s%s", QCONF_MD5_STR_LEN, value_md5_str, vals[i]);
        qhasharr_put(tbl, keys[i], value_tmp, value_tmp_len);
        free(value_tmp);
        value_tmp = NULL;
    }

    retCode = hash_tbl_set_with_md5(tbl, key, val);
    //size_t len = 0;

//	char* tmp=hash_tbl_get_with_checking_md5(tbl,key,&len);

    EXPECT_EQ(QCONF_FAILED, retCode);
}

//Test for hash_tbl_set_with_md5: key exists and slots just right enough for new value
TEST(qconf_mapTest, hash_tbl_set_with_md5_key_exists_and_slots_just_right_enough)
{
    int retCode = 0;
    const char* keys[] = {"abc", "def", "hijk", "lmn"};;
    const char* vals[] = {"123", "111", "1234", "555",};
    const char* key = "abc";
    const char* val = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz012345678901234567890";
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;
    char value_md5_int[QCONF_MD5_INT_LEN] = {0};
    char value_md5_str[QCONF_MD5_STR_LEN + 1] = {0};
    char *value_tmp = NULL;
    int value_tmp_len = 0;
    memsize = qhasharr_calculate_memsize(5);
    memory = (char*)malloc(sizeof(char) * memsize);
    tbl = qhasharr(memory, memsize);

    for(int i = 0; i < 4; i++)
    {
        qhashmd5(vals[i], strlen(vals[i]), value_md5_int);
        md5_int_to_str(value_md5_str, QCONF_MD5_STR_LEN + 1, value_md5_int, QCONF_MD5_INT_LEN);
        value_tmp_len = strlen(vals[i]) + QCONF_MD5_STR_HEAD_LEN + 1;
        value_tmp = (char*) malloc(sizeof(char) * value_tmp_len);
        snprintf(value_tmp, value_tmp_len, "%d:%s%s", QCONF_MD5_STR_LEN, value_md5_str, vals[i]);
        qhasharr_put(tbl, keys[i], value_tmp, value_tmp_len);
        free(value_tmp);
        value_tmp = NULL;
    }

    retCode = hash_tbl_set_with_md5(tbl, key, val);
    size_t len = 0;
    char* tmp = hash_tbl_get_with_checking_md5(tbl, key, &len);

    EXPECT_EQ(99ul, len);
    EXPECT_EQ(0, strcmp(val, tmp));
    EXPECT_EQ(QCONF_OK, retCode);

    free(tbl);
    tbl = NULL;
}
/**
  *End_Test_for function: int hash_tbl_set_with_md5(qhasharr_t* tbl, const char* key, char* val)
  *========================================================================================================
  */

/**
  *========================================================================================================
  *Begin_Test_for function: char* hash_tbl_get_with_checking_md5(qhasharr_t* tbl, const char* key, size_t *size)
  */

//Test for hash_tbl_get_with_checking_md5: tbl->maxslots=0
TEST(qconf_mapTest, hash_tbl_get_with_checking_md5_zero_maxslots)
{
    char* val = NULL;
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;
    const char* key = "hello";
    size_t size = 0;

    memsize = qhasharr_calculate_memsize(0);
    memory = (char*)malloc(sizeof(char) * memsize);
    tbl = (qhasharr_t*)memory;
    tbl->maxslots = 0;

    val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_EQ(NULL, val);
}

//Test for hash_tbl_get_with_checking_md5: key not exists
TEST_F(qconf_mapTestF, hash_tbl_get_with_checking_md5_key_not_exists)
{
    char* val = NULL;
    const char* key = "hello";
    size_t size = 0;

    val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_EQ(NULL, val);
}

//Test for hash_tbl_get_with_checking_md5: key exists
TEST_F(qconf_mapTestF, hash_tbl_get_with_checking_md5_key_exists)
{
    char* val = NULL;
    const char* key = "hello";
    const char* value = "123456789";
    size_t size = 0;

    hash_tbl_set_with_md5(tbl, key, value);
    val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_STREQ(val, value);
    EXPECT_EQ(9ul, size);
}

//Test for hash_tbl_get_with_checking_md5: key exists and key is truncated
TEST_F(qconf_mapTestF, hash_tbl_get_with_checking_md5_key_exists_and_key_is_truncated)
{
    char* val = NULL;
    const char* key = "abcdefghijklmnopqrstuvwxyz0123456789";
    const char* value = "1111111";
    size_t size = 0;

    hash_tbl_set_with_md5(tbl, key, value);
    val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_STREQ(val, value);
    EXPECT_EQ(7ul, size);
}

//Test for hash_tbl_get_with_checking_md5: key exists and key is truncated, get by the truncated key
TEST_F(qconf_mapTestF, hash_tbl_get_with_checking_md5_key_exists_and_key_is_truncated_get_by_truncated_key)
{
    char* val = NULL;
    const char* key = "abcdefghijklmnopqrstuvwxyz0123456789";
    const char* tkey = "abcdefghijklmnopqrstuvwxyz012345";
    const char* value = "1111111";
    size_t size = 0;

    hash_tbl_set_with_md5(tbl, key, value);
    val = hash_tbl_get_with_checking_md5(tbl, tkey, &size);

    EXPECT_EQ(NULL, val);
}

//Test for hash_tbl_get_with_checking_md5: key exists and value needs 2 slots
TEST_F(qconf_mapTestF, hash_tbl_get_with_checking_md5_key_exists_and_value_needs_two_slots)
{
    char* val = NULL;
    const char* key = "abcdefghijklmnopqrstuvwxyz0123456789";
    const char* value = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz012345678901234567890";
    size_t size = 0;

    hash_tbl_set_with_md5(tbl, key, value);
    val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_STREQ(val, value);
    EXPECT_EQ(99ul, size);
}
/**
  *End_Test_for function: char* hash_tbl_get_with_checking_md5(qhasharr_t* tbl, char* key, size_t *size)
  *======================================================================================================================
  */

/**
  *Begin_Test_for function: char* hash_tbl_get_with_checking_md5_and_key(qhasharr_t* tbl, const char *key, size_t *size)
  *======================================================================================================================
  */

//Test for hash_tbl_get_with_checking_md5_and_key
TEST_F(qconf_mapTestF, hash_tbl_get_with_checking_md5_and_key_not_exits)
{
    char* val = NULL;
    const char* key = "hello";
    size_t size = 0;

    val = hash_tbl_get_with_checking_md5_and_key(tbl, key, &size);

    EXPECT_EQ(NULL, val);
}

//Test for hash_tbl_get_with_checking_md5_and_key: key exists but not in value
TEST_F(qconf_mapTestF, hash_tbl_get_with_checking_md5_and_key_exits_but_not_in_val)
{
    char* vals = NULL;
    const char* key = "hello";
    size_t size = 0;
    const char* val = "hi";

    hash_tbl_set_with_md5(tbl, key, val);
    vals = hash_tbl_get_with_checking_md5_and_key(tbl, key, &size);

    EXPECT_EQ(NULL, vals);
}

//Test for hash_tbl_get_with_checking_md5_and_key: key exists but strlen(key)=strlen(val)
TEST_F(qconf_mapTestF, hash_tbl_get_with_checking_md5_and_key_exits_but_length_of_key_equals_with_length_of_val)
{
    char* vals = NULL;
    const char* key = "hello";
    const char* val = "12345";
    size_t size = 0;

    hash_tbl_set_with_md5(tbl, key, val);
    vals = hash_tbl_get_with_checking_md5_and_key(tbl, key, &size);

    EXPECT_EQ(NULL, vals);
}

//Test for hash_tbl_get_with_checking_md5_and_key: key exists and value is valid
TEST_F(qconf_mapTestF, hash_tbl_get_with_checking_md5_and_key_exits_and_value_valid)
{
    char* vals = NULL;
    const char* key = "hello";
    const char* val = "hello12345";
    size_t size = 0;

    hash_tbl_set_with_md5(tbl, key, val);
    vals = hash_tbl_get_with_checking_md5_and_key(tbl, key, &size);

    EXPECT_EQ(10ul, size);
    EXPECT_STREQ("hello12345", vals);
}
/**
  *End_Test_for function: char* hash_tbl_get_with_checking_md5_and_key(qhasharr_t* tbl, const char *key, size_t *size)
  *=====================================================================================================================
  */

/**
  *======================================================================================================================
  *Begin_Test_for function: int get_idc_host_from_tbl(qhasharr_t *tbl, const char* key, char* host, int host_size)
  */

//Test for get_idc_host_from_tbl: tbl->maxslots=0
TEST(qconf_mapTest, get_idc_host_from_tbl_zero_maxslots)
{
    int retCode = 0;
    qhasharr_t* tbl;
    int memsize = 0;
    char* memory = NULL;
    const char* key = "hello";
    char host[1024];
    int host_size = 1024;
    memsize = qhasharr_calculate_memsize(0);
    memory = (char*)malloc(sizeof(char) * memsize);
    tbl = (qhasharr_t*)memory;
    tbl->maxslots = 0;

    retCode = get_idc_host_from_tbl(tbl, key, host, host_size);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_idc_host_from_tbl: key not exists in tbl
TEST_F(qconf_mapTestF, get_idc_host_from_tbl_key_not_exists)
{
    int retCode = 0;
    const char* key = "hello";
    char host[1024];
    int host_size = 1024;

    retCode = get_idc_host_from_tbl(tbl, key, host, host_size);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_idc_host_from_tbl: strlen(key)=strlen(value)
TEST_F(qconf_mapTestF, get_idc_host_from_tbl_length_of_key_equals_with_length_of_val)
{
    int retCode = 0;
    const char* key = "hello";
    //const char* val = "hello";
    char host[1024];
    int host_size = 1024;

    retCode = get_idc_host_from_tbl(tbl, key, host, host_size);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_idc_host_from_tbl: key not exists in val
TEST_F(qconf_mapTestF, get_idc_host_from_tbl_length_of_key_not_exists_in_val)
{
    int retCode = 0;
    const char* key = "1:4:tesT";
    const char* val = "1:4:test14:10.15.16.17:22";
    char host[15] = {0};
    int host_size = 15;

    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_idc_host_from_tbl(tbl, key, host, host_size);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_idc_host_from_tbl: key exists in val
TEST_F(qconf_mapTestF, get_idc_host_from_tbl_key_exists_in_val)
{
    int retCode = 0;
    const char* key = "1:4:test";
    const char* val = "1:4:test14:10.15.16.17:22";
    char host[15] = {0};
    int host_size = 15;

    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_idc_host_from_tbl(tbl, key, host, host_size);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_STREQ("10.15.16.17:22", host);
}

//Test for get_idc_host_from_tbl: key exists in val but tblval_to_idcval failed
TEST_F(qconf_mapTestF, get_idc_host_from_tbl_length_of_key_exists_in_val_but_tblval_to_idcval_failed)
{
    int retCode = 0;
    const char* key = "2:4:test";
    const char* val = "2:4:test14:10.15.16.17:22";
    char host[15] = {0};
    int host_size = 15;

    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_idc_host_from_tbl(tbl, key, host, host_size);

    EXPECT_EQ(QCONF_ERR_DATA_TYPE, retCode);
}
/**
  *End_Test_for function: int get_idc_host_from_tbl(qhasharr_t *tbl, const char* key, char* host, int host_size)
  *==============================================================================================================
  */

/**
  *Begin_Test_for function: int get_node_from_tbl(qhasharr_t *tbl, const char* key, char** val_buf, int *buf_size)
  *==============================================================================================================
  */

//Test for get_node_from_tbl: tbl->maxslots=0
TEST(qconf_mapTest, get_node_from_tbl_zero_maxslots)
{
    int retCode = 0;
    const char* key = "hello";
    char* val_buf = NULL;
    int buf_size = 0;
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;

    memsize = qhasharr_calculate_memsize(0);
    memory = (char*)malloc(sizeof(char) * memsize);
    tbl = (qhasharr_t*)memory;
    tbl->maxslots = 0;

    retCode = get_node_from_tbl(tbl, key, &val_buf, &buf_size);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_node_from_tbl: key not exists
TEST_F(qconf_mapTestF, get_node_from_tbl_key_not_exists)
{
    int retCode = 0;
    const char* key = "hello";
    char* val_buf = NULL;
    int buf_size = 0;

    retCode = get_node_from_tbl(tbl, key, &val_buf, &buf_size);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_node_from_tbl: strlen(key)=strlen(tblval)
TEST_F(qconf_mapTestF, get_node_from_tbl_length_of_key_equals_with_length_of_val)
{
    int retCode = 0;
    const char* key = "hello";
    const char* val = "hello";
    char* val_buf = NULL;
    int buf_size = 0;

    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_node_from_tbl(tbl, key, &val_buf, &buf_size);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_node_from_tbl: key not in tblval
TEST_F(qconf_mapTestF, get_node_from_tbl_key_not_in_tblval)
{
    int retCode = 0;
    const char* key = "2:4:corpT";
    const char* val = "2:4:corp26:/qconf/__qconf_anchor_node0:qconfAnchor";
    char* val_buf = NULL;
    int buf_size = 0;

    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_node_from_tbl(tbl, key, &val_buf, &buf_size);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_node_from_tbl: key exists in tblval
TEST_F(qconf_mapTestF, get_node_from_tbl_key_exists_in_tblval)
{
    int retCode = 0;
    const char* key = "2:4:corp26:/qconf/__qconf_anchor_node";
    const char* val = "2:4:corp26:/qconf/__qconf_anchor_node11:qconfAnchor";
    char* val_buf = NULL;
    int buf_size = 0;

    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_node_from_tbl(tbl, key, &val_buf, &buf_size);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_STREQ("qconfAnchor", val_buf);
    EXPECT_EQ(11, buf_size);
}

//Test for get_node_from_tbl: key exists in tblval but tblval_to_nodeval failed
TEST_F(qconf_mapTestF, get_node_from_tbl_key_exists_in_tblval_but_tblval_to_nodeval_failed)
{
    int retCode = 0;
    const char* key = "1,4,corp26,/qconf/__qconf_anchor_node";
    const char* val = "1,4,corp26,/qconf/__qconf_anchor_node11:qconfAnchor";
    char* val_buf = NULL;
    int buf_size = 0;

    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_node_from_tbl(tbl, key, &val_buf, &buf_size);

    EXPECT_EQ(QCONF_ERR_DATA_TYPE, retCode);
}
/**
  *End_Test_for function: int get_node_from_tbl(qhasharr_t *tbl, const char* key, char** val_buf, int *buf_size)
  *===============================================================================================================
  */

/**
  *===============================================================================================================
  *Begin_Test_for function: int get_chd_from_tbl(qhasharr_t *tbl, const char* key, String_vector_t *nodes)
  */

//Test for get_chd_from_tbl: tbl->maxslots=0
TEST(qconf_mapTest, get_chd_from_tbl_zero_maxslots)
{
    int retCode = 0;
    const char* key = "hello";
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;
    String_vector_t nodes;

    memset(&nodes, 0, sizeof(nodes));
    memory = (char*)malloc(sizeof(char) * memsize);
    tbl = (qhasharr_t*)memory;
    tbl->maxslots = 0;

    retCode = get_chd_from_tbl(tbl, key, &nodes);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_chd_from_tbl: key not exists
TEST_F(qconf_mapTestF, get_chd_from_tbl_key_not_exists_in_tbl)
{
    int retCode = 0;
    const char* key = "hello";
    String_vector_t nodes;

    memset(&nodes, 0, sizeof(nodes));
    retCode = get_chd_from_tbl(tbl, key, &nodes);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_chd_from_tbl: strlen(key)=strlen(tblval)
TEST_F(qconf_mapTestF, get_chd_from_tbl_length_of_key_equals_with_length_of_val)
{
    int retCode = 0;
    const char* key = "hello";
    const char* val = "hello";
    String_vector_t nodes;

    memset(&nodes, 0, sizeof(nodes));
    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_chd_from_tbl(tbl, key, &nodes);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_chd_from_tbl: key not in tblval
TEST_F(qconf_mapTestF, get_chd_from_tbl_length_of_key_not_in_tbl)
{
    int retCode = 0;
    const char* key = "helloT";
    const char* val = "hello12345";
    String_vector_t nodes;

    memset(&nodes, 0, sizeof(nodes));
    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_chd_from_tbl(tbl, key, &nodes);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for get_chd_from_tbl: key in tblval
TEST_F(qconf_mapTestF, get_chd_from_tbl_key_in_tblval)
{
    int retCode = 0;
    const char* key = "3:4:corp26:/qconf/__qconf_anchor_node";
    const char* val = "3:4:corp26:/qconf/__qconf_anchor_node2:12:127.0.0.1:8012:127.0.0.2:80";
    String_vector_t nodes;

    memset(&nodes, 0, sizeof(nodes));
    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_chd_from_tbl(tbl, key, &nodes);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(2, nodes.count);
    EXPECT_STREQ("127.0.0.1:80", nodes.data[0]);
    EXPECT_STREQ("127.0.0.2:80", nodes.data[1]);
}

//Test for get_chd_from_tbl: key in tblval but tblval_to_chdnodeval failed
TEST_F(qconf_mapTestF, get_chd_from_tbl_key_in_tblval_but_tblval_to_chdnodeval_failed)
{
    int retCode = 0;
    const char* key = "1:4:corp26:/qconf/__qconf_anchor_node";
    const char* val = "1:4:corp26:/qconf/__qconf_anchor_node2:12:127.0.0.1:8012:127.0.0.2:80";
    String_vector_t nodes;

    memset(&nodes, 0, sizeof(nodes));
    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_chd_from_tbl(tbl, key, &nodes);

    EXPECT_EQ(QCONF_ERR_DATA_TYPE, retCode);
}

//Test for get_chd_from_tbl: key in tblval but tblval_to_chdnodeval failed since null value)
TEST_F(qconf_mapTestF, get_chd_from_tbl_key_in_tblval_but_tblval_to_chdnodeval_failed_since_null_val)
{
    int retCode = 0;
    const char* key = "3:4:corp26:/qconf/__qconf_anchor_node";
    const char* val = "3:4:corp26:/qconf/__qconf_anchor_node0:";
    String_vector_t nodes;

    memset(&nodes, 0, sizeof(nodes));
    hash_tbl_set_with_md5(tbl, key, val);
    retCode = get_chd_from_tbl(tbl, key, &nodes);

    EXPECT_EQ(QCONF_ERR_NULL_VALUE, retCode);
}
/**
  *End_Test_for function: int get_chd_from_tbl(qhasharr_t *tbl, const char* key, String_vector_t *nodes)
  *======================================================================================================
  */

/**
  *======================================================================================================
  *Begin_Test_for function: int update_tbl_by_node(qhasharr_t *tbl, const char *key, const char *nodeval, int nodeval_len)
  */

//Test for update_tbl_by_node: tbl->maxslots=0
TEST(qconf_mapTest, update_tbl_by_node_zero_maxslots)
{
    int retCode = 0;
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;
    const char* key = "2:4:corp11:/qconf/demo";
    const char* nodeval = "demo-test";
    memsize = qhasharr_calculate_memsize(0);
    memory = (char*)malloc(sizeof(char) * memsize);
    memset(memory, 0, memsize);
    tbl = (qhasharr_t*)memory;

    retCode = update_tbl_by_node(tbl, key, nodeval, 9);

    EXPECT_EQ(QCONF_FAILED, retCode);
}

//Test for update_tbl_by_node: nodeval=NULL
TEST_F(qconf_mapTestF, update_tbl_by_node_null_nodeval)
{
    int retCode = 0;
    const char* key = "2:4:corp11:/qconf/demo";
    char* nodeval = NULL;
    size_t size = 0;

    retCode = update_tbl_by_node(tbl, key, nodeval, 0);
    char* val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_STREQ("2:4:corp11:/qconf/demo0:", val);
    EXPECT_EQ(24ul, size);
}

//Test for update_tbl_by_node: empty nodeval
TEST_F(qconf_mapTestF, update_tbl_by_node_empty_nodeval)
{
    int retCode = 0;
    const char* key = "2:4:corp11:/qconf/demo";
    const char* nodeval = "";
    size_t size = 0;

    retCode = update_tbl_by_node(tbl, key, nodeval, 0);
    char* val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_STREQ("2:4:corp11:/qconf/demo0:", val);
    EXPECT_EQ(24ul, size);
}

//Test for update_tbl_by_node: not empty nodeval
TEST_F(qconf_mapTestF, update_tbl_by_node_not_empty_nodeval)
{
    int retCode = 0;
    const char* key = "2:4:corp11:/qconf/demo";
    const char* nodeval = "demo-test";
    size_t size = 0;

    retCode = update_tbl_by_node(tbl, key, nodeval, 9);
    char* val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_STREQ("2:4:corp11:/qconf/demo9:demo-test", val);
    EXPECT_EQ(33ul, size);
}

//Test for update_tbl_by_node: key already exists and update by the same value
TEST_F(qconf_mapTestF, update_tbl_by_node_key_already_exists_and_update_by_the_same_value)
{
    int retCode = 0;
    const char* key = "2:4:corp11:/qconf/demo";
    const char* nodeval = "demo-test";
    const char* val = "2:4:corp11:/qconf/demo9:demo-test";
    size_t size = 0;

    hash_tbl_set_with_md5(tbl, key, val);
    retCode = update_tbl_by_node(tbl, key, nodeval, 9);
    char* tmp = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_EQ(QCONF_ERR_SAME_VALUE, retCode);
    EXPECT_EQ(33ul, size);
    EXPECT_STREQ("2:4:corp11:/qconf/demo9:demo-test", tmp);
}

//Test for update_tbl_by_node: key already and exists and update by the different value
TEST_F(qconf_mapTestF, update_tbl_by_node_key_already_exists_and_update_by_the_different_value)
{
    int retCode = 0;
    const char* key = "2:4:corp11:/qconf/demo";
    const char* nodeval = "demo-test";
    const char* val = "2:4:corp11:/qconf/demo0:demo-test";
    size_t size = 0;

    hash_tbl_set_with_md5(tbl, key, val);
    retCode = update_tbl_by_node(tbl, key, nodeval, 9);
    char* tmp = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(33ul, size);
    EXPECT_STREQ("2:4:corp11:/qconf/demo9:demo-test", tmp);
}
/**
  *End_Test_for function: int update_tbl_by_node(qhasharr_t *tbl, const char *key, const char *nodeval, int nodeval_len)
  *================================================================================================
  */

/**
  *================================================================================================
  *Begin_Test_for function: int update_tbl_by_idc_host(qhasharr_t *tbl, const char* key, const char* host)
  */

//Test for update_tbl_by_idc_host: tbl->maxslots=0
TEST(qconf_mapTest, update_tbl_by_idc_host_zero_maxslots)
{
    int retCode = 0;
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;
    const char* key = "1:4:test";
    const char* host = "10.15.16.17.11:22";
    memsize = qhasharr_calculate_memsize(0);
    memory = (char*)malloc(sizeof(char) * memsize);
    tbl = (qhasharr_t*)memory;
    tbl->maxslots = 0;

    retCode = update_tbl_by_idc_host(tbl, key, host);

    EXPECT_EQ(QCONF_ERR_TBL_SET, retCode);
}

//Test for update_tbl_by_idc_host: key not exists int tb;
TEST_F(qconf_mapTestF, update_tbl_by_idc_host_key_not_exists)
{
    int retCode = 0;
    const char* key = "1:4:test";
    const char* host = "10.15.16.17:22";
    size_t size = 0;
    char* val = NULL;

    retCode = update_tbl_by_idc_host(tbl, key, host);
    val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(25ul, size);
    EXPECT_STREQ("1:4:test14:10.15.16.17:22", val);
    free(val);
    val = NULL;
}

//Test for update_tbl_by_idc_host: key already exists and update by the same value
TEST_F(qconf_mapTestF, update_tbl_by_idc_host_key_already_exists_and_update_by_the_same_value)
{
    int retCode = 0;
    const char* key = "1:4:test";
    const char* host = "10.15.16.17:22";
    const char* tblval = "1:4:test14:10.15.16.17:22";
    size_t size = 0;
    char* val = NULL;

    hash_tbl_set_with_md5(tbl, key, tblval);
    retCode = update_tbl_by_idc_host(tbl, key, host);
    val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_EQ(QCONF_ERR_TBL_SET, retCode);
    EXPECT_EQ(25ul, size);
    EXPECT_STREQ("1:4:test14:10.15.16.17:22", val);
    free(val);
    val = NULL;
}

//Test for update_tbl_by_idc_host: key already exists and update by the different value
TEST_F(qconf_mapTestF, update_tbl_by_idc_host_key_already_exists_and_update_by_the_different_value)
{
    int retCode = 0;
    const char* key = "1:4:test";
    const char* host = "10.15.16.17:22";
    const char* tblval = "1:4:test14:10.15.16.17:21";
    size_t size = 0;
    char* val = NULL;

    hash_tbl_set_with_md5(tbl, key, tblval);
    retCode = update_tbl_by_idc_host(tbl, key, host);
    val = hash_tbl_get_with_checking_md5(tbl, key, &size);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(25ul, size);
    EXPECT_STREQ("1:4:test14:10.15.16.17:22", val);
    free(val);
    val = NULL;
}
/**
  *End_Test_for function: int update_tbl_by_idc_host(qhasharr_t *tbl, const char* key, const char* host)
  *====================================================================================================
  */

/**
  *====================================================================================================
  *Begin_Test_for function: int update_tbl_by_chd(qhasharr_t *tbl, const char *key, String_vector_t *nodes, char* valid_flg)
  */

//Test for update_tbl_by_chd: tbl->maxslots=0
TEST(qconf_mapTest, update_tbl_by_chd_zero_maxslots)
{
    int retCode = 0;
    qhasharr_t* tbl = NULL;
    int memsize = 0;
    char* memory = NULL;
    const char* key = "3:4:corp26:/qconf/__qconf_anchor_node";
    String_vector_t nodes = {0};
    char valid_flg[2] = {1, 1};
    char tmp[1024] = {0};

    nodes.count = 2;
    nodes.data = (char**)malloc(sizeof(char*)*nodes.count);

    for(int i = 0; i < 2; i++)
    {
        snprintf(tmp, 1024, "10.15.16.17:%d", i);
        nodes.data[i] = (char*)malloc(sizeof(char) * (strlen(tmp) + 1));
        memcpy(nodes.data[i], tmp, strlen(tmp));
        nodes.data[i][strlen(tmp)] = '\0';
    }

    memsize = qhasharr_calculate_memsize(0);
    memory = (char*)malloc(sizeof(char) * memsize);
    tbl = (qhasharr_t*)memory;
    tbl->maxslots = 0;

    retCode = update_tbl_by_chd(tbl, key, &nodes, valid_flg);

    EXPECT_EQ(QCONF_ERR_TBL_SET, retCode);
}

//Test for update_tbl_by_chd: key exists and update by the same val
TEST_F(qconf_mapTestF, update_tbl_by_chd_update_by_the_same_val)
{
    int retCode = 0;
    const char* key = "3:4:corp26:/qconf/__qconf_anchor_node";
    String_vector_t nodes = {0};
    char valid_flg[2] = {1, 1};
    char tmp[1024] = {0};
    int buf_size = 0;
    char* buf = NULL;

    nodes.count = 2;
    nodes.data = (char**)malloc(sizeof(char*)*nodes.count);

    for(int i = 0; i < 2; i++)
    {
        snprintf(tmp, 1024, "10.15.16.17:%d", i);
        nodes.data[i] = (char*)malloc(sizeof(char) * (strlen(tmp) + 1));
        memcpy(nodes.data[i], tmp, strlen(tmp));
        nodes.data[i][strlen(tmp)] = '\0';
    }

    buf_size = calc_chdnode_tblval_size(key, &nodes, valid_flg);
    buf = (char*)malloc(buf_size * sizeof(char));
    chdnodeval_to_tblval(key, &nodes, buf, buf_size, valid_flg);
    hash_tbl_set_with_md5(tbl, key, buf);
    retCode = update_tbl_by_chd(tbl, key, &nodes, valid_flg);

    EXPECT_EQ(QCONF_ERR_SAME_VALUE, retCode);
}

////Test for update_tbl_by_chd: key exists and update by the different val
TEST_F(qconf_mapTestF, update_tbl_by_chd_update_by_the_different_val)
{
    int retCode = 0;
    const char* key = "3:4:corp26:/qconf/__qconf_anchor_node";
    String_vector_t nodes = {0};
    char valid_flg[2] = {1, 1};
    char valid_flg_new[2] = {0, 0};
    char tmp[1024] = {0};
    int buf_size = 0;
    char* buf = NULL;

    nodes.count = 2;
    nodes.data = (char**)malloc(sizeof(char*)*nodes.count);

    for(int i = 0; i < 2; i++)
    {
        snprintf(tmp, 1024, "10.15.16.17:%d", i);
        nodes.data[i] = (char*)malloc(sizeof(char) * (strlen(tmp) + 1));
        memcpy(nodes.data[i], tmp, strlen(tmp));
        nodes.data[i][strlen(tmp)] = '\0';
    }

    buf_size = calc_chdnode_tblval_size(key, &nodes, valid_flg);
    buf = (char*)malloc(buf_size * sizeof(char));
    chdnodeval_to_tblval(key, &nodes, buf, buf_size, valid_flg);
    hash_tbl_set_with_md5(tbl, key, buf);
    retCode = update_tbl_by_chd(tbl, key, &nodes, valid_flg_new);
    size_t size = 0;
    char* val = hash_tbl_get_with_checking_md5_and_key(tbl, key, &size);
    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(2, nodes.count);
    EXPECT_STREQ("3:4:corp26:/qconf/__qconf_anchor_node0:", val);
}

//Test for update_tbl_by_chd: key exists and update by the different val,old nodes all invalid,but new nodes all valid
TEST_F(qconf_mapTestF, update_tbl_by_chd_update_by_the_different_val_new_nodes_all_valid)
{
    int retCode = 0;
    const char* key = "3:4:corp26:/qconf/__qconf_anchor_node";
    String_vector_t nodes = {0};
    char valid_flg_new[2] = {1, 1};
    char valid_flg[2] = {0, 0};
    char tmp[1024] = {0};
    int buf_size = 0;
    char* buf = NULL;

    nodes.count = 2;
    nodes.data = (char**)malloc(sizeof(char*)*nodes.count);

    for(int i = 0; i < 2; i++)
    {
        snprintf(tmp, 1024, "10.15.16.17:%d", i);
        nodes.data[i] = (char*)malloc(sizeof(char) * (strlen(tmp) + 1));
        memcpy(nodes.data[i], tmp, strlen(tmp));
        nodes.data[i][strlen(tmp)] = '\0';
    }

    buf_size = calc_chdnode_tblval_size(key, &nodes, valid_flg);
    buf = (char*)malloc(buf_size * sizeof(char));
    chdnodeval_to_tblval(key, &nodes, buf, buf_size, valid_flg);
    hash_tbl_set_with_md5(tbl, key, buf);
    retCode = update_tbl_by_chd(tbl, key, &nodes, valid_flg_new);
    size_t size = 0;
    char* val = hash_tbl_get_with_checking_md5_and_key(tbl, key, &size);
    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(2, nodes.count);
    EXPECT_STREQ("3:4:corp26:/qconf/__qconf_anchor_node2:13:10.15.16.17:013:10.15.16.17:1", val);
}

//Test for update_tbl_by_chd: key not exists
TEST_F(qconf_mapTestF, update_tbl_by_chd_key_not_exists)
{
    int retCode = 0;
    const char* key = "3:4:corp26:/qconf/__qconf_anchor_node";
    String_vector_t nodes = {0};
    char valid_flg_new[2] = {1, 1};
    //char valid_flg[2] = {0, 0};
    char tmp[1024] = {0};
    //int buf_size = 0;
    //char* buf = NULL;

    nodes.count = 2;
    nodes.data = (char**)malloc(sizeof(char*)*nodes.count);

    for(int i = 0; i < 2; i++)
    {
        snprintf(tmp, 1024, "10.15.16.17:%d", i);
        nodes.data[i] = (char*)malloc(sizeof(char) * (strlen(tmp) + 1));
        memcpy(nodes.data[i], tmp, strlen(tmp));
        nodes.data[i][strlen(tmp)] = '\0';
    }

    retCode = update_tbl_by_chd(tbl, key, &nodes, valid_flg_new);
    size_t size = 0;
    char* val = hash_tbl_get_with_checking_md5_and_key(tbl, key, &size);
    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_EQ(2, nodes.count);
    EXPECT_STREQ("3:4:corp26:/qconf/__qconf_anchor_node2:13:10.15.16.17:013:10.15.16.17:1", val);
}
/**
  *End_Test_for function: int update_tbl_by_chd(qhasharr_t *tbl, const char *key, String_vector_t *nodes, char* valid_flg)
  *=======================================================================================================================
  */


/**
  *Begin_Test_for function: int hash_tbl_remove(qhasharr_t *tbl, char *key)
  *=======================================================================================================-=================
  */

//Test for hash_tbl_remove: tbl->maxslots=0
TEST(qconf_mapTest, hash_tbl_remove)
{
    int retCode = 0;

    EXPECT_EQ(QCONF_OK, retCode);
}

//Test for hash_tbl_remove: key not exists
TEST_F(qconf_mapTestF, hash_tbl_remove_key_not_exists)
{
    int retCode = 0;
    const char* key = "hello";

    retCode = hash_tbl_remove(tbl, key);

    EXPECT_EQ(QCONF_ERR_NOT_FOUND, retCode);
}

//Test for hash_tbl_remove: key exists
TEST_F(qconf_mapTestF, hash_tbl_remove_key_exists)
{
    int retCode = 0;
    const char* key = "hello";
    const void* val = "12345";

    qhasharr_put(tbl, key, val, 6);
    retCode = hash_tbl_remove(tbl, key);
    bool exists = qhasharr_exist(tbl, key);

    EXPECT_EQ(QCONF_OK, retCode);
    EXPECT_FALSE(exists);
    EXPECT_EQ(0, tbl->usedslots);
    EXPECT_EQ(0, tbl->num);
}

//Test for hash_tbl_remove:
TEST_F(qconf_mapTestF, hash_tbl_remove_all_key_exists)
{
    int retCode = 0;
    const char* keys[] = {"abc", "def", "hijk", "lmn", "opq"};
    const char* vals[] = {"1234", "111", "aaaa", "bbb", "1"};
//    bool exists = false;

    for(int i = 0; i < 5; i++)
    {
        qhasharr_put(tbl, keys[i], vals[i], strlen(vals[i]) + 1);
    }

    for(int i = 0; i < 5; i++)
    {
        retCode -= hash_tbl_remove(tbl, keys[i]);
        EXPECT_FALSE(qhasharr_exist(tbl, keys[i]));
    }

    EXPECT_EQ(0, retCode);
    EXPECT_EQ(0, tbl->usedslots);
    EXPECT_EQ(0, tbl->num);
}
/**
  *End_Test_for function: int hash_tbl_remove(qhasharr_t *tbl, char *key)
  *============================================================================================================
  */

/**
  *Begin_Test_for function:
  *============================================================================================================
  */













